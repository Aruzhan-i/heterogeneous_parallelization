#include <iostream>              // Подключаем библиотеку для ввода и вывода (cout, cin)
#include <fstream>               // Подключаем библиотеку для работы с файлами
#include <vector>                // Подключаем контейнер std::vector
#include <random>                // Подключаем генераторы случайных чисел
#include <cstdint>               // Подключаем типы фиксированной длины (uint64_t и др.)
#include <filesystem>            // Подключаем работу с файловой системой (папки, пути)
#include <sstream>               // Подключаем stringstream для формирования строк
#include <cstdlib>               // Подключаем стандартные функции (strtoull и др.)

// Сохраняет массив float в бинарный файл
static void save_bin(const std::string& path, const std::vector<float>& a){ // Функция сохранения массива в бинарный файл
  std::ofstream f(path, std::ios::binary);                                 // Открываем файл в бинарном режиме на запись
  if(!f) throw std::runtime_error("cannot open file for write: " + path);  // Проверяем, удалось ли открыть файл

  // Сначала записываем размер массива
  uint64_t n = (uint64_t)a.size();                                          // Получаем размер массива и приводим к uint64_t
  f.write((char*)&n, sizeof(n));                                           // Записываем размер массива в файл

  // Затем сами данные
  f.write((char*)a.data(), (std::streamsize)(a.size()*sizeof(float)));     // Записываем все элементы массива как бинарные данные
}

int main(int argc, char** argv){                                           // Точка входа в программу, принимает аргументы командной строки
  // Размер массива по умолчанию
  size_t n = 1000000;                                                      // Устанавливаем размер массива по умолчанию

  // Если передали аргумент — читаем его
  if(argc >= 2)                                                            // Проверяем, передан ли аргумент
    n = static_cast<size_t>(std::strtoull(argv[1], nullptr, 10));          // Преобразуем аргумент в число и задаём новый размер

  // Создаём папку results, если её нет
  std::filesystem::create_directories("results");                          // Создаём директорию results (если уже есть — ничего не делает)

  // Генератор случайных чисел
  std::mt19937 rng(42);                                                    // Инициализируем генератор случайных чисел с фиксированным seed
  std::uniform_real_distribution<float> dist(0.f, 1.f);                   // Задаём равномерное распределение в диапазоне [0, 1]

  // Создаём массив
  std::vector<float> a(n);                                                 // Создаём вектор из n элементов типа float
  double checksum = 0.0;                                                   // Переменная для хранения контрольной суммы

  // Заполняем массив и считаем сумму
  for(size_t i=0;i<n;i++){                                                 // Проходим по всем элементам массива
    a[i] = dist(rng);                                                      // Заполняем элемент случайным числом
    checksum += a[i];                                                      // Добавляем значение к контрольной сумме
  }

  // Формируем имя файла без std::to_string
  std::ostringstream ss;                                                   // Создаём строковый поток
  ss << "results/data_" << n << ".bin";                                    // Формируем имя файла с размером массива
  std::string out = ss.str();                                              // Получаем готовую строку имени файла

  // Сохраняем данные
  save_bin(out, a);                                                        // Вызываем функцию сохранения массива в файл

  // Выводим информацию
  std::cout << "Сгенерирован массив размером n = " << n << "\n";           // Печатаем размер массива
  std::cout << "Файл сохранён: " << out << "\n";                           // Печатаем путь к файлу
  std::cout << "Контрольная сумма (сумма на CPU) = " << checksum << "\n";  // Печатаем контрольную сумму
  return 0;                                                                // Завершаем программу с кодом успеха
}
