// Подключение стандартной библиотеки ввода и вывода,
// необходимой для использования cout, wcout, cin, wcin
#include <iostream>

// Подключение библиотеки для работы с генератором
// псевдослучайных чисел (rand, srand)
#include <cstdlib>

// Подключение библиотеки для работы со временем,
// используется для инициализации генератора случайных чисел
#include <ctime>

// Подключение библиотеки OpenMP,
// необходимой для параллельного программирования
#include <omp.h>

// Подключение заголовочного файла для работы
// с файловыми дескрипторами в Windows
#include <io.h>

// Подключение заголовочного файла для настройки
// режима ввода-вывода консоли (UTF-16)
#include <fcntl.h>

// Подключение стандартного пространства имён,
// чтобы не писать std:: перед каждым объектом стандартной библиотеки
using namespace std;

/*
 * Функция последовательного вычисления среднего значения массива
 * arr  — указатель на первый элемент динамического массива
 * size — количество элементов в массиве
 */
double calculateAverage(int* arr, int size) {

    // Объявление переменной sum для хранения суммы элементов массива.
    // Тип long long используется, чтобы избежать переполнения
    // при суммировании большого количества чисел.
    long long sum = 0;

    // Цикл for для последовательного обхода всех элементов массива
    for (int i = 0; i < size; i++) {

        // Добавление текущего элемента массива к общей сумме
        sum += arr[i];
    }

    // Возвращение среднего значения:
    // сумма элементов делится на количество элементов массива.
    // static_cast<double> используется для приведения типов,
    // чтобы получить вещественный результат.
    return static_cast<double>(sum) / size;
}

/*
 * Функция параллельного вычисления среднего значения массива
 * Используется технология OpenMP
 */
double calculateAverageParallel(int* arr, int size) {

    // Переменная sum для хранения суммы элементов массива.
    // В дальнейшем она будет использоваться в операции reduction.
    long long sum = 0;

    /*
     * Директива OpenMP, указывающая компилятору,
     * что цикл for должен выполняться параллельно.
     *
     * reduction(+:sum) означает:
     *  - каждый поток получает собственную локальную копию переменной sum
     *  - после завершения цикла локальные суммы объединяются
     *    с помощью операции сложения
     */
    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i < size; i++) {

        // Добавление текущего элемента массива
        // к локальной сумме конкретного потока
        sum += arr[i];
    }

    // Возвращение среднего значения массива
    return static_cast<double>(sum) / size;
}

int main() {

    /*
     * Установка режима ввода стандартного потока
     * в UTF-16 для корректного ввода кириллицы в Windows
     */
    _setmode(_fileno(stdin), _O_U16TEXT);

    /*
     * Установка режима вывода стандартного потока
     * в UTF-16 для корректного вывода кириллицы в Windows
     */
    _setmode(_fileno(stdout), _O_U16TEXT);

    // Объявление переменной n для хранения размера массива
    int n;

    // Вывод сообщения пользователю с запросом размера массива
    wcout << L"Введите размер массива: ";

    // Считывание введённого пользователем значения
    // из стандартного потока ввода
    wcin >> n;

    // Проверка: удалось ли корректно считать число
    if (wcin.fail()) {

        // Вывод сообщения об ошибке,
        // если пользователь ввёл нечисловые данные
        wcout << L"Ошибка: необходимо ввести целое число.\n";

        // Завершение программы с кодом ошибки
        return 1;
    }

    // Проверка: является ли введённое число положительным
    if (n <= 0) {

        // Вывод сообщения об ошибке,
        // если размер массива некорректен
        wcout << L"Ошибка: размер массива должен быть положительным.\n";

        // Завершение программы с кодом ошибки
        return 1;
    }

    /*
     * Параллельная область OpenMP.
     * Используется для определения количества потоков.
     */
    #pragma omp parallel
    {
        /*
         * Директива single гарантирует,
         * что данный блок выполнится только одним потоком,
         * чтобы избежать повторного вывода информации
         */
        #pragma omp single
        {
            // Вывод количества потоков OpenMP,
            // используемых в текущем параллельном регионе
            wcout << L"OpenMP threads: "
                  << omp_get_num_threads() << endl;
        }
    }

    // Динамическое выделение памяти под массив целых чисел
    int* array = new int[n];

    // Инициализация генератора случайных чисел
    // текущим временем для получения разных последовательностей
    srand(static_cast<unsigned>(time(nullptr)));

    // Цикл для заполнения массива случайными числами
    for (int i = 0; i < n; i++) {

        // Присваивание элементу массива
        // случайного значения в диапазоне от 0 до 99
        array[i] = rand() % 100;
    }

    // Переменные для хранения времени начала и окончания
    // последовательного вычисления
    double t_seq_start, t_seq_end;

    // Переменные для хранения времени начала и окончания
    // параллельного вычисления
    double t_par_start, t_par_end;

    // Фиксация времени начала последовательного вычисления
    t_seq_start = omp_get_wtime();

    // Вызов функции последовательного вычисления среднего значения
    double avg_seq = calculateAverage(array, n);

    // Фиксация времени окончания последовательного вычисления
    t_seq_end = omp_get_wtime();

    // Вычисление времени выполнения последовательного алгоритма
    double seq_time = t_seq_end - t_seq_start;

    // Фиксация времени начала параллельного вычисления
    t_par_start = omp_get_wtime();

    // Вызов функции параллельного вычисления среднего значения
    double avg_par = calculateAverageParallel(array, n);

    // Фиксация времени окончания параллельного вычисления
    t_par_end = omp_get_wtime();

    // Вычисление времени выполнения параллельного алгоритма
    double par_time = t_par_end - t_par_start;

    // Вывод результата последовательного вычисления среднего значения
    wcout << L"\nСреднее значение (последовательно): " << avg_seq << endl;

    // Вывод времени выполнения последовательного алгоритма
    wcout << L"Время (последовательно): " << seq_time << L" сек\n";

    // Вывод результата параллельного вычисления среднего значения
    wcout << L"\nСреднее значение (параллельно, OpenMP): " << avg_par << endl;

    // Вывод времени выполнения параллельного алгоритма
    wcout << L"Время (параллельно): " << par_time << L" сек\n";

    // Проверка, можно ли корректно вычислить ускорение
    if (par_time > 0 && seq_time > 0) {

        // Вычисление ускорения как отношения
        // времени последовательного выполнения
        // ко времени параллельного выполнения
        wcout << L"\nУскорение (Speedup): "
              << (seq_time / par_time) << endl;
    } else {

        // Сообщение, если время слишком мало
        // для корректного измерения ускорения
        wcout << L"\nУскорение: невозможно измерить (слишком малое время)\n";
    }

    // Освобождение ранее выделенной динамической памяти
    delete[] array;

    // Завершение программы с кодом успешного выполнения
    return 0;
}
