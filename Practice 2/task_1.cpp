// Подключение стандартной библиотеки ввода-вывода.
// Необходима для использования cout, cin, endl и других средств вывода.
#include <iostream>

// Подключение контейнера vector из стандартной библиотеки.
// vector используется как динамический массив.
#include <vector>

// Подключение библиотеки генерации случайных чисел.
// Используется для mt19937 и uniform_int_distribution.
#include <random>

// Подключение библиотеки chrono.
// Используется для измерения времени выполнения алгоритмов.
#include <chrono>

// Использование стандартного пространства имён std.
// Позволяет не писать std:: перед cout, vector и т.д.
using namespace std;

// Использование пространства имён chrono.
// Позволяет напрямую использовать high_resolution_clock и duration.
using namespace chrono;


// Функция пузырьковой сортировки.
// Принимает вектор по ссылке, чтобы сортировка происходила "на месте".
void bubbleSort(vector<int>& a) {

    // Получаем количество элементов в массиве.
    int n = a.size();

    // Внешний цикл определяет количество проходов по массиву.
    // После каждого прохода наибольший элемент перемещается в конец.
    for (int i = 0; i < n - 1; i++) {

        // Внутренний цикл сравнивает соседние элементы.
        // Диапазон уменьшается, так как конец массива уже отсортирован.
        for (int j = 0; j < n - 1 - i; j++) {

            // Если текущий элемент больше следующего,
            // выполняем обмен элементов.
            if (a[j] > a[j + 1])
                swap(a[j], a[j + 1]);
        }
    }
}


// Функция сортировки выбором.
// На каждом шаге выбирается минимальный элемент и ставится в начало.
void selectionSort(vector<int>& a) {

    // Получаем размер массива.
    int n = a.size();

    // Внешний цикл задаёт позицию,
    // на которую будет помещён минимальный элемент.
    for (int i = 0; i < n - 1; i++) {

        // Предполагаем, что минимальный элемент находится на позиции i.
        int minIdx = i;

        // Внутренний цикл ищет минимальный элемент
        // в неотсортированной части массива.
        for (int j = i + 1; j < n; j++) {

            // Если найден элемент меньше текущего минимума,
            // обновляем индекс минимального элемента.
            if (a[j] < a[minIdx])
                minIdx = j;
        }

        // Меняем местами текущий элемент и найденный минимум.
        swap(a[i], a[minIdx]);
    }
}


// Функция сортировки вставками.
// Постепенно формирует отсортированную часть массива слева.
void insertionSort(vector<int>& a) {

    // Получаем количество элементов массива.
    int n = a.size();

    // Начинаем со второго элемента,
    // так как первый элемент считается отсортированным.
    for (int i = 1; i < n; i++) {

        // Сохраняем текущий элемент,
        // который необходимо вставить в отсортированную часть.
        int key = a[i];

        // Индекс для движения влево по отсортированной части.
        int j = i - 1;

        // Пока индекс не вышел за границы массива
        // и текущий элемент больше вставляемого,
        // выполняем сдвиг элементов вправо.
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            j--;
        }

        // Вставляем элемент key на корректную позицию.
        a[j + 1] = key;
    }
}


// Функция генерации массива случайных чисел.
// n — размер массива.
vector<int> generateArray(int n) {

    // Создаём вектор заданного размера.
    vector<int> a(n);

    // Генератор псевдослучайных чисел Mersenne Twister.
    // Используется фиксированное зерно (42),
    // чтобы результаты экспериментов были воспроизводимыми.
    mt19937 rng(42);

    // Равномерное распределение целых чисел
    // в диапазоне от 0 до 100000.
    uniform_int_distribution<int> dist(0, 100000);

    // Заполняем массив случайными значениями.
    for (int& x : a) {
        x = dist(rng);
    }

    // Возвращаем заполненный массив.
    return a;
}


int main() {

    // Набор размеров массивов для тестирования производительности.
    // Используются массивы из 1000, 10000 и 100000 элементов.
    vector<int> sizes = {1000, 10000, 100000};

    // Цикл по каждому размеру массива.
    for (int n : sizes) {

        // Вывод текущего размера массива.
        cout << "\nArray size: " << n << endl;

        // Генерируем базовый массив случайных чисел.
        vector<int> base = generateArray(n);

        // Создаём копии массива для каждой сортировки,
        // чтобы все алгоритмы работали с одинаковыми данными.
        vector<int> aBubble = base;
        vector<int> aSelect = base;
        vector<int> aInsert = base;

        // ================= Bubble Sort =================

        // Фиксируем время начала пузырьковой сортировки.
        auto t1 = high_resolution_clock::now();

        // Запускаем пузырьковую сортировку.
        bubbleSort(aBubble);

        // Фиксируем время окончания сортировки.
        auto t2 = high_resolution_clock::now();

        // Вычисляем время выполнения в миллисекундах.
        double bubbleTime =
            duration<double, milli>(t2 - t1).count();

        // ================= Selection Sort =================

        // Фиксируем время начала сортировки выбором.
        auto t3 = high_resolution_clock::now();

        // Запускаем сортировку выбором.
        selectionSort(aSelect);

        // Фиксируем время окончания сортировки.
        auto t4 = high_resolution_clock::now();

        // Вычисляем время выполнения.
        double selectionTime =
            duration<double, milli>(t4 - t3).count();

        // ================= Insertion Sort =================

        // Фиксируем время начала сортировки вставками.
        auto t5 = high_resolution_clock::now();

        // Запускаем сортировку вставками.
        insertionSort(aInsert);

        // Фиксируем время окончания сортировки.
        auto t6 = high_resolution_clock::now();

        // Вычисляем время выполнения.
        double insertionTime =
            duration<double, milli>(t6 - t5).count();

        // ================= Вывод результатов =================

        // Вывод времени выполнения пузырьковой сортировки.
        cout << "Bubble sort time:    " << bubbleTime << " ms\n";

        // Вывод времени выполнения сортировки выбором.
        cout << "Selection sort time: " << selectionTime << " ms\n";

        // Вывод времени выполнения сортировки вставками.
        cout << "Insertion sort time: " << insertionTime << " ms\n";
    }

    // Завершение программы с кодом успешного выполнения.
    return 0;
}
