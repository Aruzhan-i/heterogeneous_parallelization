
#include <iostream>
#include <vector>
#include <random>

// Подключение библиотеки chrono.
// Используется для измерения времени выполнения алгоритмов.
#include <chrono>

// Подключение библиотеки OpenMP.
// Нужна для директив #pragma omp parallel for.
#include <omp.h>

using namespace std;

// Использование пространства имён chrono,
// чтобы обращаться к high_resolution_clock, duration и т.д.
using namespace chrono;



// Функция последовательной сортировки пузырьком.
// Принимает массив по ссылке, чтобы сортировать его на месте.
void bubbleSort(vector<int>& a) {

    // Получаем количество элементов в массиве.
    int n = a.size();

    // Внешний цикл определяет количество проходов по массиву.
    // После каждого прохода наибольший элемент перемещается в конец.
    for (int i = 0; i < n - 1; i++)

        // Внутренний цикл выполняет сравнение соседних элементов.
        // Граница уменьшается, так как конец массива уже отсортирован.
        for (int j = 0; j < n - 1 - i; j++)

            // Если текущий элемент больше следующего,
            // выполняется обмен элементов.
            if (a[j] > a[j + 1])
                swap(a[j], a[j + 1]);
}


// Функция параллельной сортировки пузырьком.
// Используется алгоритм odd-even sort,
// который является параллельной модификацией пузырька.
void bubbleSortParallel(vector<int>& a) {

    // Получаем количество элементов массива.
    int n = a.size();

    // Внешний цикл задаёт фазы сортировки.
    // Обычно требуется n фаз для полной сортировки.
    for (int phase = 0; phase < n; phase++) {

        // Определяем начальный индекс:
        // 0 — для чётной фазы, 1 — для нечётной.
        int start = phase % 2;

        // Параллельный цикл OpenMP.
        // Каждая итерация обрабатывает независимую пару элементов.
        #pragma omp parallel for
        for (int i = start; i < n - 1; i += 2)

            // Сравнение элементов пары и обмен при необходимости.
            if (a[i] > a[i + 1])
                swap(a[i], a[i + 1]);
    }
}


// Функция генерации массива случайных чисел.
// n — размер массива.
vector<int> generateArray(int n) {

    // Создаём вектор размером n.
    vector<int> a(n);

    // Генератор псевдослучайных чисел Mersenne Twister.
    // Фиксированное зерно (42) обеспечивает воспроизводимость.
    mt19937 rng(42);

    // Равномерное распределение целых чисел
    // в диапазоне от 0 до 100000.
    uniform_int_distribution<int> dist(0, 100000);

    // Заполняем массив случайными значениями.
    for (int& x : a)
        x = dist(rng);

    // Возвращаем заполненный массив.
    return a;
}


int main() {

    // Вектор размеров массивов для тестирования производительности.
    // Используются размеры 1000, 10 000 и 100 000 элементов.
    vector<int> sizes = {1000, 10000, 100000};

    // Цикл по каждому размеру массива.
    for (int n : sizes) {

        // Генерируем исходный массив случайных чисел.
        vector<int> a1 = generateArray(n);

        // Создаём копию массива для параллельной сортировки,
        // чтобы обе версии работали с одинаковыми данными.
        vector<int> a2 = a1;

        // Фиксируем время начала последовательной сортировки.
        auto t1 = high_resolution_clock::now();

        // Запускаем последовательную пузырьковую сортировку.
        bubbleSort(a1);

        // Фиксируем время окончания последовательной сортировки.
        auto t2 = high_resolution_clock::now();

        // Фиксируем время начала параллельной сортировки.
        auto t3 = high_resolution_clock::now();

        // Запускаем параллельную пузырьковую сортировку.
        bubbleSortParallel(a2);

        // Фиксируем время окончания параллельной сортировки.
        auto t4 = high_resolution_clock::now();

        // Вычисляем время последовательной версии в миллисекундах.
        double seqTime = duration<double, milli>(t2 - t1).count();

        // Вычисляем время параллельной версии в миллисекундах.
        double parTime = duration<double, milli>(t4 - t3).count();

        // Выводим размер массива.
        cout << "\nArray size: " << n << endl;

        // Выводим время выполнения последовательной версии.
        cout << "Sequential time: " << seqTime << " ms\n";

        // Выводим время выполнения параллельной версии.
        cout << "Parallel time:   " << parTime << " ms\n";

        // Вычисляем и выводим ускорение (Speedup),
        // как отношение последовательного времени к параллельному.
        cout << "Speedup:         " << seqTime / parTime << "x\n";
    }

    // Завершение программы с кодом успешного выполнения.
    return 0;
}
