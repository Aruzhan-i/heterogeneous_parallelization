#include <iostream>   // Подключаем библиотеку стандартного ввода-вывода (cout, cin, endl)
#include <cstdlib>    // Подключаем библиотеку для работы с rand(), srand() и system()
#include <ctime>      // Подключаем библиотеку для получения текущего времени (time)
#include <chrono>     // Подключаем библиотеку для измерения времени выполнения программы
#include <omp.h>      // Подключаем библиотеку OpenMP для параллельных вычислений

using namespace std;          // Используем стандартное пространство имён std
using namespace chrono;       // Используем пространство имён chrono для работы с таймерами

int main() {                  // Главная функция программы, с неё начинается выполнение

    // Переключаем кодировку консоли Windows на UTF-8 для корректного отображения русского текста
    system("chcp 65001 > nul");

    int SIZE;                 // Объявляем переменную для хранения размера массива

    // Выводим сообщение с просьбой ввести размер массива
    cout << "Введите размер массива: ";
    // Считываем введённый пользователем размер массива
    cin >> SIZE;

    // Проверяем, что размер массива положительный
    if (SIZE <= 0) {
        // Если размер некорректный, выводим сообщение об ошибке
        cout << "Ошибка: размер массива должен быть положительным числом." << endl;
        // Завершаем программу с кодом ошибки
        return 1;
    }

    // Выводим сообщение о запуске программы
    cout << "\nПрограмма запущена." << endl;
    // Сообщаем о выделении памяти под массив
    cout << "Выделяем память под массив из " << SIZE << " целых чисел." << endl;

    // Динамически выделяем память под массив целых чисел заданного размера
    int* arr = new int[SIZE];

    // Инициализируем генератор случайных чисел текущим временем
    srand(time(nullptr));

    // Сообщаем о начале заполнения массива случайными числами
    cout << "Заполняем массив случайными числами..." << endl;

    // Цикл заполнения массива случайными числами
    for (int i = 0; i < SIZE; i++) {
        // Генерируем случайное число от 1 до 1 000 000 и записываем в массив
        arr[i] = rand() % 1000000 + 1;
    }

    // Сообщаем, что массив успешно заполнен
    cout << "Массив успешно заполнен." << endl;

    // =====================================================
    // ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК MIN / MAX
    // =====================================================

    // Инициализируем переменную минимума первым элементом массива
    int seqMin = arr[0];
    // Инициализируем переменную максимума первым элементом массива
    int seqMax = arr[0];

    // Сообщаем о запуске последовательного алгоритма
    cout << "Запуск последовательного алгоритма..." << endl;

    // Запоминаем момент начала выполнения последовательного алгоритма
    auto seqStart = high_resolution_clock::now();

    // Последовательный проход по массиву для поиска минимума и максимума
    for (int i = 1; i < SIZE; i++) {
        // Если текущий элемент меньше текущего минимума — обновляем минимум
        if (arr[i] < seqMin) seqMin = arr[i];
        // Если текущий элемент больше текущего максимума — обновляем максимум
        if (arr[i] > seqMax) seqMax = arr[i];
    }

    // Запоминаем момент окончания выполнения последовательного алгоритма
    auto seqEnd = high_resolution_clock::now();
    // Вычисляем время выполнения последовательного алгоритма в микросекундах
    auto seqDuration = duration_cast<microseconds>(seqEnd - seqStart);

    // =====================================================
    // ПАРАЛЛЕЛЬНЫЙ ПОИСК MIN / MAX (OpenMP reduction)
    // =====================================================

    // Инициализируем минимум для параллельной версии первым элементом массива
    int parMin = arr[0];
    // Инициализируем максимум для параллельной версии первым элементом массива
    int parMax = arr[0];

    // Сообщаем о запуске параллельного алгоритма
    cout << "Запуск параллельного алгоритма (OpenMP)..." << endl;

    // Запоминаем момент начала выполнения параллельного алгоритма
    auto parStart = high_resolution_clock::now();

    // Параллельный цикл OpenMP с редукцией минимума и максимума
    #pragma omp parallel for reduction(min:parMin) reduction(max:parMax)
    for (int i = 1; i < SIZE; i++) {
        // Если текущий элемент меньше локального минимума — обновляем минимум
        if (arr[i] < parMin) parMin = arr[i];
        // Если текущий элемент больше локального максимума — обновляем максимум
        if (arr[i] > parMax) parMax = arr[i];
    }

    // Запоминаем момент окончания выполнения параллельного алгоритма
    auto parEnd = high_resolution_clock::now();
    // Вычисляем время выполнения параллельного алгоритма в микросекундах
    auto parDuration = duration_cast<microseconds>(parEnd - parStart);

    // =====================================================
    // ВЫВОД РЕЗУЛЬТАТОВ
    // =====================================================

    // Выводим результаты последовательного алгоритма
    cout << "\nПоследовательный алгоритм:" << endl;
    // Выводим найденные минимум и максимум
    cout << "Минимум = " << seqMin << ", Максимум = " << seqMax << endl;
    // Выводим время выполнения последовательного алгоритма
    cout << "Время выполнения = " << seqDuration.count() << " мкс." << endl;

    // Выводим результаты параллельного алгоритма
    cout << "\nПараллельный алгоритм (OpenMP):" << endl;
    // Выводим найденные минимум и максимум
    cout << "Минимум = " << parMin << ", Максимум = " << parMax << endl;
    // Выводим время выполнения параллельного алгоритма
    cout << "Время выполнения = " << parDuration.count() << " мкс." << endl;

    // Проверяем, совпадают ли результаты последовательного и параллельного алгоритмов
    if (seqMin != parMin || seqMax != parMax) {
        // Если результаты не совпадают — выводим предупреждение
        cout << "\n ВНИМАНИЕ: результаты не совпадают!" << endl;
    }

    // Сообщаем об освобождении динамически выделенной памяти
    cout << "\nОсвобождаем динамически выделенную память." << endl;
    // Освобождаем память, выделенную под массив
    delete[] arr;

    // Сообщаем о корректном завершении программы
    cout << "Программа завершена корректно." << endl;
    // Возвращаем 0 — успешное завершение программы
    return 0;
}
