// Подключение стандартной библиотеки ввода-вывода
// Используется для cout, endl и вывода результатов
#include <iostream>

// Подключение контейнера vector
// vector используется как динамический массив
#include <vector>

// Подключение библиотеки генерации случайных чисел
// Нужна для random_device, mt19937 и uniform_int_distribution
#include <random>

// Подключение библиотеки chrono
// Используется для измерения времени выполнения алгоритмов
#include <chrono>

// Подключение библиотеки с граничными значениями типов
// INT_MAX и INT_MIN
#include <climits>

// Подключение библиотеки OpenMP
// Используется для параллельного программирования
#include <omp.h>

// Использование стандартного пространства имён std
using namespace std;

// Использование пространства имён chrono
using namespace chrono;

// =========================
// Последовательная версия
// =========================

// Функция последовательной сортировки выбором
// Принимает массив по ссылке для сортировки "на месте"
void selectionSortSequential(vector<int>& arr) {

    // Получение размера массива
    int n = arr.size();

    // Внешний цикл — проход по массиву
    for (int i = 0; i < n - 1; i++) {

        // Индекс минимального элемента
        int minIndex = i;

        // Внутренний цикл — поиск минимального элемента
        for (int j = i + 1; j < n; j++) {

            // Сравнение текущего элемента с текущим минимумом
            if (arr[j] < arr[minIndex]) {

                // Обновление индекса минимального элемента
                minIndex = j;
            }
        }

        // Обмен текущего элемента с найденным минимальным
        swap(arr[i], arr[minIndex]);
    }
}

// =========================
// Параллельная версия OpenMP
// =========================

// Функция параллельной сортировки выбором
// Использует OpenMP для ускорения поиска минимума
void selectionSortParallel(vector<int>& arr) {

    // Получение размера массива
    int n = arr.size();

    // Внешний цикл остаётся последовательным
    for (int i = 0; i < n - 1; i++) {

        // Текущее минимальное значение
        int minValue = arr[i];

        // Индекс текущего минимального значения
        int minIndex = i;

        // Начало параллельной области
        #pragma omp parallel
        {
            // Локальная копия минимального значения для потока
            int localMinValue = minValue;

            // Локальный индекс минимума для потока
            int localMinIndex = minIndex;

            // Параллельный цикл по оставшейся части массива
            // nowait — без барьера синхронизации
            #pragma omp for nowait
            for (int j = i + 1; j < n; j++) {

                // Поиск локального минимума в потоке
                if (arr[j] < localMinValue) {

                    // Обновление локального минимума
                    localMinValue = arr[j];

                    // Обновление локального индекса минимума
                    localMinIndex = j;
                }
            }

            // Критическая секция для объединения результатов потоков
            #pragma omp critical
            {
                // Сравнение локального минимума с глобальным
                if (localMinValue < minValue) {

                    // Обновление глобального минимума
                    minValue = localMinValue;

                    // Обновление глобального индекса
                    minIndex = localMinIndex;
                }
            }
        }

        // Обмен текущего элемента с найденным минимумом
        swap(arr[i], arr[minIndex]);
    }
}

// =========================
// Тест производительности
// =========================

// Функция тестирования производительности сортировки
// size — размер тестируемого массива
void runTest(int size) {

    // Основной массив
    vector<int> arr(size);

    // Копия массива для параллельной версии
    vector<int> arrCopy;

    // Источник случайности
    random_device rd;

    // Генератор псевдослучайных чисел
    mt19937 gen(rd());

    // Диапазон случайных чисел
    uniform_int_distribution<int> dist(1, 100000);

    // Заполнение массива случайными значениями
    for (int i = 0; i < size; i++) {
        arr[i] = dist(gen);
    }

    // Копирование массива
    arrCopy = arr;

    // -------------------------
    // Последовательная версия
    // -------------------------

    // Фиксация времени начала
    auto startSeq = high_resolution_clock::now();

    // Запуск последовательной сортировки
    selectionSortSequential(arr);

    // Фиксация времени окончания
    auto endSeq = high_resolution_clock::now();

    // -------------------------
    // Параллельная версия
    // -------------------------

    // Фиксация времени начала
    auto startPar = high_resolution_clock::now();

    // Запуск параллельной сортировки
    selectionSortParallel(arrCopy);

    // Фиксация времени окончания
    auto endPar = high_resolution_clock::now();

    // Вывод размера массива
    cout << "Размер массива: " << size << endl;

    // Вывод времени последовательной версии
    cout << "Последовательная версия: "
         << duration_cast<milliseconds>(endSeq - startSeq).count()
         << " мс" << endl;

    // Вывод времени параллельной версии
    cout << "Параллельная версия (OpenMP): "
         << duration_cast<milliseconds>(endPar - startPar).count()
         << " мс" << endl;

    // Разделитель вывода
    cout << "-----------------------------------" << endl;
}

// Главная функция программы
int main() {

    // Заголовок тестирования
    cout << "Тестирование сортировки выбором\n\n";

    // Тест для массива размером 1000
    runTest(1000);

    // Тест для массива размером 10000
    runTest(10000);

    // Возврат 0 — успешное завершение программы
    return 0;
}
