// Подключение стандартной библиотеки ввода-вывода
#include <iostream>

// Подключение контейнера vector для работы с динамическими массивами
#include <vector>

// Подключение библиотеки генерации случайных чисел
#include <random>

// Подключение библиотеки для измерения времени выполнения
#include <chrono>

// Подключение библиотеки с граничными значениями типов (INT_MAX, INT_MIN)
#include <climits>

// Подключение библиотеки OpenMP для параллельного программирования
#include <omp.h>

// Использование стандартного пространства имён std
using namespace std;

// Использование пространства имён chrono для работы со временем
using namespace chrono;

// Точка входа в программу
int main() {

    // Константа, задающая размер массива
    const int SIZE = 10000;

    // Создание вектора целых чисел размером SIZE
    vector<int> arr(SIZE);

    // ----------------------------
    // Генерация случайных чисел
    // ----------------------------

    // Источник случайности для инициализации генератора
    random_device rd;

    // Генератор псевдослучайных чисел Mersenne Twister
    mt19937 gen(rd());

    // Распределение для генерации чисел в диапазоне от 1 до 100000
    uniform_int_distribution<int> dist(1, 100000);

    // Цикл заполнения массива случайными значениями
    for (int i = 0; i < SIZE; i++) {

        // Генерация случайного числа и запись его в массив
        arr[i] = dist(gen);
    }

    // ============================
    // Последовательная реализация
    // ============================

    // Переменная для хранения минимального значения (последовательно)
    int min_seq = INT_MAX;

    // Переменная для хранения максимального значения (последовательно)
    int max_seq = INT_MIN;

    // Фиксация времени начала последовательного вычисления
    auto start_seq = high_resolution_clock::now();

    // Последовательный проход по массиву
    for (int i = 0; i < SIZE; i++) {

        // Проверка, является ли текущий элемент минимальным
        if (arr[i] < min_seq)
            min_seq = arr[i];

        // Проверка, является ли текущий элемент максимальным
        if (arr[i] > max_seq)
            max_seq = arr[i];
    }

    // Фиксация времени окончания последовательного вычисления
    auto end_seq = high_resolution_clock::now();

    // Вычисление длительности выполнения в микросекундах
    auto duration_seq = duration_cast<microseconds>(end_seq - start_seq);

    // ============================
    // Параллельная реализация (OpenMP)
    // ============================

    // Переменная для хранения минимума в параллельной версии
    int min_par = INT_MAX;

    // Переменная для хранения максимума в параллельной версии
    int max_par = INT_MIN;

    // Фиксация времени начала параллельного вычисления
    auto start_par = high_resolution_clock::now();

    // Параллельный цикл OpenMP
    // reduction(min:min_par) — корректно объединяет локальные минимумы потоков
    // reduction(max:max_par) — корректно объединяет локальные максимумы потоков
    #pragma omp parallel for reduction(min:min_par) reduction(max:max_par)
    for (int i = 0; i < SIZE; i++) {

        // Обновление локального минимума потока
        if (arr[i] < min_par)
            min_par = arr[i];

        // Обновление локального максимума потока
        if (arr[i] > max_par)
            max_par = arr[i];
    }

    // Фиксация времени окончания параллельного вычисления
    auto end_par = high_resolution_clock::now();

    // Вычисление длительности выполнения в микросекундах
    auto duration_par = duration_cast<microseconds>(end_par - start_par);

    // ============================
    // Вывод результатов
    // ============================

    // Вывод заголовка для последовательной версии
    cout << "Последовательная реализация:" << endl;

    // Вывод минимального значения
    cout << "Минимум: " << min_seq << endl;

    // Вывод максимального значения
    cout << "Максимум: " << max_seq << endl;

    // Вывод времени выполнения последовательной версии
    cout << "Время выполнения: " << duration_seq.count() << " мкс" << endl;

    // Пустая строка для визуального разделения вывода
    cout << endl;

    // Вывод заголовка для параллельной версии
    cout << "Параллельная реализация (OpenMP):" << endl;

    // Вывод минимального значения
    cout << "Минимум: " << min_par << endl;

    // Вывод максимального значения
    cout << "Максимум: " << max_par << endl;

    // Вывод времени выполнения параллельной версии
    cout << "Время выполнения: " << duration_par.count() << " мкс" << endl;

    // Возврат 0 — успешное завершение программы
    return 0;
}
